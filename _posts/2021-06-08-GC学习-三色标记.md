---
layout:     post   				    # 使用的布局（不需要改）
title:      GC学习				# 标题 
subtitle:   三色标记 			 #副标题
date:       2021-06-08			# 时间
author:     去休 						# 作者
header-img: img/78391247_p0.png 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - GC
---

# JVM栈的作用及特点

# GC学习-三色标记

追踪式垃圾回收的思想就是判断对象是否可达，可达意味着有初始起点，Java中定义四种**GCROOTS**

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI（即一般说的native方法）中引用的对象

传统的垃圾清除机制是复制、标记清除、标记压缩，但无论哪种都是先做标记，找到需要清理的对象。三色标记法的好处是可以异步执行，从而可以以STW极少的代价来进行整个 GC。

$\color{white}{白色}$： 初始状态

$\color{grey}{灰色}$：已扫描状态，但是至少还有一个引用没有被扫描

$\color{black}{黑色}$：已扫描，且所有引用已扫描（不会再次被遍历）

![img](https://gitee.com/quxiu/Image/raw/master/20210608111310.webp)

浮动垃圾：应该要清理的对象标记成存活

与此相反，如果把存活对象标记成需要清理，就是有问题的了

充要条件：1.插入了一条或者多条黑色到白色对象的引用

​					2.删除了全部从灰色到白色对象的引用

比如：删除灰色到白色的引用，将白色接入到黑色引用中。

![img](https://gitee.com/quxiu/Image/raw/master/20210608111403.webp)

解决方案：增量更新和原始快照

CMS-增量更新：记录新插入的引用，扫描结束之后，再以黑色对象为根重新扫描一次。新插入的记录再扫一次！

G1-原始快照：记录要删除的引用，扫描结束之后，以灰色对象为根重新扫描一次，最终还是会按照之前的关系重新来一次。